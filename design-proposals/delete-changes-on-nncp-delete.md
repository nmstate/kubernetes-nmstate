# Delete nmstate configuration from the system on NNCP deletion

## Summary

We want kubernetes-nmstate to delete changes made by an NNCP when that NNCP is deleted.

## TLDR

Deleting NNCP will do whatever applying output of `nmstatectl gr` does.

## Motivation

Users find it confusing that deleting the NNCP does not remove the changes it applied. The current workflow for removing such a configuration is to apply the same NNCP but with `state: absent`. As we have `nmstatectl gr` that generates a network state reverting the desired state, we are able to make the behavior of NNCP easier for users.

### User Stories

1) As a cluster admin I apply NNCP that creates a VLAN. I want that deleting this NNCP removes the VLAN.

2) As a cluster admin I apply NNCP that defines static IP address on an interface. I want that deleting this NNCP removes this IP address from the interface.

### Goals

1) We want users to have a consistent behavior between `nmstatectl gr` and NNCP deletion. The behavior when deleting NNCP should be aligned with what would happen if user generated manifest using `nmstatectl gr` and applied it as NNCP.

2) We want kubernetes-nmstate to use its health probes to block removal of NNCP if that would break connectivity to the node.

### Non-Goals

1) We are not supporting removal/revert of the configuration when NNCP is modified.

2) We are not taking snapshot of network configuration before NNCP was applied in order to revert to that snapshot. We are only deleting changes that specific NNCP applies.

## Proposal

We want to add an opt-in feature at the level of NNCP that would make deleting this NNCP to delete changes it applies.

### Workflow Description

As cluster admin has ability to configure NNCP with `deleteOnRemoval: true` (or similar, decided below, field). Such an NNCP when treated with `oc delete nncp my-nncp-using-this-feature` will go through the kubernetes finalizer process that internally generates so-called "revert state" using `nmstatectl gr` and applies that state.

From the cluster admin perspective this process is transparent and happens synchronously to the `oc delete` command.

As a side effect to non-goal 1., NNCP using this feature becomes immutable. This is discussed in detail below.

Sample NNCP using this feature is presented below

```
  apiVersion: nmstate.io/v1beta1
  kind: NodeNetworkConfigurationPolicy
  metadata:
    name: example-vlan
  spec:
    deleteOnRemoval: true
    desiredState:
      interfaces:
        - name: eth0.100
          type: vlan
          state: up
          vlan:
            base-iface: eth0
            id: 100
```

### Confusing deletion semantics

We are intentionally using `nmstatectl gr` instead of implementing own parser. This is to ensure consistent behavior for users using both `nmstatectl` and kubernetes-nmstate. As a consequence, any requests for change of undesired behavior will be routed through the nmstate project to be first implemented there.

We do not plan to introduce any special cases where NNCP delete would behave differently from `nmstatectl gr`.

### Error handling

It may happen that change generated by `nmstatectl gr` causes loss of connectivity to the cluster. In order to prevent that, we will go through the full process of running connectivity probes. This will happen synchronously inside a finalizer so that unless connectivity is proven to work, finalizer is not removed.

This introduces a side effect of potentially non-deletable NNCPs. We accept this scenario because as a cluster admin you will have ability to

* opt-out from the feature for a specific NNCP; in such a case nothing changes on the system when NNCP is deleted
* stop `oc delete nncp` command, go back to your system and fix any changes that prevent successful change

### Immutability

A consequence of non-goal 1. is that we do not allow modification of NNCP marked with `deleteOnRemoval`. This is mainly to avoid misunderstandings in a scenario when user fundamentally changes the content of their NNCP. Let's take an example of the following spec

```
interfaces:
- name: eth0
  type: ethernet
  state: up
  ipv4:
    address:
    - ip: 192.168.122.250
      prefix-length: 24
    enabled: true
```

and then modification to the following

```
- name: eth1
  type: ethernet
  state: up
  ipv4:
    address:
    - ip: 192.168.100.192
      prefix-length: 24
    enabled: true
```

In this scenario we stopped managing `eth0` completely. With `deleteOnRemoval` user could expect that this implicitly deletes IP address from `eth0`, but another user could expect that this does not happen.

In order to prevent any confusion, any changes to NNCP are forbidden. This includes desired configuration but also e.g. node selectors. The only allowed change will be modifying the `deleteOnRemoval` flag.

### DNS configuration

A consequence of non-goal 2. is that for a specific NNCP we do not know what was the network configuration before it was applied. For this reason we don't call the feature "revert the changes" but rather "delete the changes". As an example let's take a system configured first with

```
dns-resolver:
  config:
    search:
    - example.com
    server:
    - 8.8.8.8
```

and later with

```
dns-resolver:
  config:
    search:
    - example.org
    server:
    - 1.1.1.1
```

As the second change overrides the first one, we have no ability to actually go back to `8.8.8.8` after only deleting the second manifest. Semantics of `nmstatectl gr` for DNS configuration is that reverting static DNS will set `auto-dns` even if DHCP has not been enabled.

We do not foresee implementing additional mechanisms to keep history of system configurations.

### Handling physical and virtual interfaces

We do not introduce anything special on that front. Semantics for reverting NNCP that created a virtual interface is to remove that interface. For a physical interface it is to set the interface down and disable IP configuration.

### API Extensions

We are extending `.spec` of NodeNetworkConfigurationPolicy CRD to contain `deleteOnRemoval: true|false`. Every NNCP can be configured independently.

### Implementation Details/Notes/Constraints

#### Immutability

Immutability of NNCPs will be provided by the webhook that makes sure changes are rejected. It needs to make sure that for immutable NNCP user is allowed to change the `deleteOnRemoval` flag.

#### Finalizers

The whole logic should be implemented inside a finalizer. Every NNCP (no matter its configuration) will be annotated with a finalizer.

Inside the finalizer function we check for the `deleteOnRemoval` flag. If not configured, it's a simple no-op, we delete the finalizer and kubernetes removes the NNCP object.

If `deleteOnRemoval` is configured, we internally run `nmstatectl gr` and store its output.

> **NOTE:** It should not happen but in case nmstatectl fails here, it will require a human to debug. We will neither continue nor abort. By kubernetes behavior, we will be stuck on deleting state with finalizer still in place. Only after the issue is understood and fixed we can proceed.

From the moment we have nmstate YAML defining state after deleting the changes. We internally run the logic to apply this manifest. We should use exactly the same logic that we have for the logic when a new NNCP is applied (e.g. node selectors, max unavailability rules).

During this step we need to run regular set of k-nmstate probes validating the connectivity. This is so that `nmstatectl gr` does not leave us with a node with broken connectivity. In case after applying `nmstatectl gr` generated manifest we lose the connectivity, we should go back and apply manifest defined by the NNCP's `.spec` (kind of revert the revert but not exactly).

When all above succeeded, we remove the finalizer. From this moment kubernetes takes over and deletes the NNCP object.

### Risks and Mitigations

Errors inside finalizers are tricky. There is no user-friendly channel to communicate with outside world when inside a finalizer function. For this reason it may happen that `oc delete nncp [...]` appears as stuck when there are still operations happening. However, it may also appear as stuck when unrecoverable error occured. Unfortunately by using kubernetes as-is, it is what it is.

1) First and obvious, we should make the finalizer logic robust so that it cannot fail. The most error-prone places are respecting max unavailability rules and logic for retrying failed NNCPs. We control all those so it is on us to make sure this works well.

2) Another failure path is when applying `nmstatectl gr` manifest renders the node unusable. This can be for variety of reasons. Imagine DC network configuration that requires a VLAN, we then delete NNCP defining that and as a result, we lose connectivity with default gateway. Inside finalizer function we need a logic that detects that and applies back the original state of the NNCP to restore the connectivity.

> **NOTE:** The above paragraph has some corner cases when applying `nmstatectl gr` and then appying the NNCP back may not get you back to the original state. Without further details, this may be when there were some interdependent NNCPs (that one should not have). We can't handle all the possible scenarios and we should accept the fact that you always have an ability to break yourself.

3) Last and not least, we need to educate cluster admins about interactions with finalizers. From the perspective of the operator sitting in front of the terminal all they see is that `oc delete nncp [...]` command keeps running. They need to have a procedure where to go and which log to check in order to understand if the finalizer is still in progress (and they only need to wait) or it failed in a potentially fatal way (i.e. unrecoverably lost connectivity).

### Upgrade Strategy

During upgrade to the first version supporting this feature all the pre-existing NNCPs should be treated as `deleteOnRemoval: false`.
